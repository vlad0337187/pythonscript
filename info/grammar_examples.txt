Main standards:
       Elegance:
               not overdosing with tokens, better using real words
       Similarity to Python, CoffeeScript code
       Usability:
               almost all may could be combined as user wishes.
               all code could be written in one line, or could be written in
                       separate lines, depends on what developer think

Collections types:
       Literals:
               Lists:
                       l{1, 2, 3, 4, 'a'}
               Tuples:
                       t{1, 3, 'b'}
               Sets:
                       s{a, 3, 5, 'b'}
               Dictionaries:
                       d{'a': 'b', 3: 2}
       Taking by index:
               Lists:
                       a = l{1, 2, 3, 4}
                       a[1]  # will give 1
                       a [2]  # will give 2
                       a [-1]  # will give 4
                       a[-2]  # will give 3
               Tuples:
                       are taking analogically to Lists
               Sets, Dicts:
                       doesn't support
       Taking by key:
               Dicts:
                       a = d{}'a': 'b', 2: 3}
                       a['a']  # will give 'b'
                       a [2]  # will give 3
               Lists, Tuples, Sets:
                       doesn't support
       Taking slices:
               Lists:
                       a = l{1, 2, 3, 4, 'a'}
                       a[1..3]  # will give l[1, 2, 3]
                       a [2 .. -2]  # will give l[2, 3, 4]
                       a [1..-1 .. 2]  # will give l[1, 3, 'a']
               Tuples:
                       analogically to Lists.
               Sets, Dictionaries:
                       doesn't support


Generators:
       List generators:
               l{x for x in somevariable}
               l{x for x in l{1, 2, 3} if x != 2}
               l{i for i, v in t{t{1, 3}, t{3, 4}, t{5, 6}}}
       Tuple generators:
               t{x for x in somevariable}
               t{x for x in t{1, 2} if expression}
       Dictionaries generators:
               d{key: value for variable in other_variable}
               d{key: value for variable in other_variable}


Try/Except blocks:
       try
               expression
       except Exception
               expression
       finally
               expression

       try
               expression
       except Exception as inst
               expression
       finally
               expression

       try: expression; expression_2
       except Exception: expression
       finally
               expression

       try: expression; expression_2; except Exception as inst: expression; finally: expression


Functions:
       Definition:
               function name = arg1, arg2, **kwargs: expression; expression2

               name = def arg1, arg2: expression

               name = def arg1, arg2, **kwargs
                       expression

               name = def arg1, arg2: expression

               def name argument: expression; expression_2

               a = def (*args, **kwargs): expression

               a = def (arg, *args)
                       expression
       Running functions:
               a = def (): return 4
               a ()  # will run function without arguments
               a()  # same thing
               do a

               printer = def (*args): print args
               printer(arg_1, arg_2)
               printer (arg_1, arg_2)
       Also they can be passed as arguments to other functions:
               l = def (func, argument_2): func(); print argument_2
               l (def (): print "something";, argument_2)
               l def (): print "something";, argument_2


Scopes and brackets:
       "{}" are used for defining collections
       "()" are used for grouping
       "[]" are using for taking arguments and slices
       old:
               "[]" are used for defining collections, slices and generators
               instead of:
                       #"()" are used  in function launcing and arguments passing no
                       #"{}" are used for grouping anything no.
               we can launch empty or general functions with "do" operator, arguments may
                       be passed after spacing after the name of function


Inner implementation details:
       package consists of 3 main parts:
               tokens (list of all used in language tokens)
               scanner (scans souce code and creates list of found tokens (token stream))
               parser (scans list of found tokens (token stream), makes AST from it)
               modulule_creator (resulting AST packs into module, adds to sys.modules)
               package_finder
                       (finds .python files, packages (directories with __init__.python)
                       from sys.path directories)
               organizer
                       (after calling "uses()" function launches all other components by order)
       there would be no difference for compiler: in which line of something is,
               the only matter for containing token's lines is for showing user as debug
               info
